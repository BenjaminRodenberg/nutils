#! /usr/bin/env python

from __future__ import division
from nutils import *


@log.title
def makeplots( domain, geom, velo, pres, index ):

  xy, uv = domain.elem_eval( [ geom, velo ], ischeme='uniform2', separate=False )
  points, velo, pres, div = domain.elem_eval( [ geom, function.norm2(velo), pres, velo.div(geom) ], ischeme='bezier5', separate=True )

  with plot.PyPlot( 'velo', index=index, ndigits=4 ) as plt:
    plt.mesh( points, velo, triangulate='bezier' )
    plt.clim( 0, 1 )
    plt.colorbar()
    plt.quiver( xy[:,0], xy[:,1], uv[:,0], uv[:,1] )

  with plot.PyPlot( 'pres', index=index, ndigits=4 ) as plt:
    plt.mesh( points, pres, triangulate='bezier' )
    plt.colorbar()

  with plot.PyPlot( 'div', index=index, ndigits=4 ) as plt:
    plt.mesh( points, div, triangulate='bezier' )
    plt.colorbar()


def main( nelems=8, viscosity=1e-3, density=1, warp=False, plot=True, tol=1e-5, maxiter=numpy.inf ):

  Re = density / viscosity # based on unit length and velocity
  log.user( 'reynolds number: {:.1f}'.format(Re) )

  verts = numpy.linspace( 0, 1, nelems+1 )
  domain, geom = mesh.rectilinear( [verts,verts] )
  pbasis = domain.basis( 'spline', degree=1 )
  vbasis = function.vectorize([
    domain.basis( 'spline', degree=(2,1), removedofs=((0,-1),None) ),
    domain.basis( 'spline', degree=(1,2), removedofs=(None,(0,-1)) ) ])

  if warp:
    x, y = geom
    geom = (y+2) * function.rotmat(x*.4)[:,1] - (0,2) # slight downward bend
    J = function.localgradient( geom, domain.ndims )
    detJ = function.determinant( J )
    vbasis = ( vbasis[...,_,:] * J ).sum(-1) / detJ # piola transform
    pbasis = pbasis / detJ

  vbasis, pbasis, lbasis = function.chain([ vbasis, pbasis, [1] ])
  stressbasis = (2*viscosity) * vbasis.symgrad(geom) - (pbasis)[:,_,_] * function.eye( domain.ndims )

  A = function.outer( vbasis.grad(geom), stressbasis ).sum([2,3]) \
    + function.outer( pbasis, vbasis.div(geom)+lbasis ) \
    + function.outer( lbasis, pbasis )
  stokesmat = domain.integrate( A, geometry=geom, ischeme='gauss9' )

  utop = geom.tangent([1,0]).normalized()
  h = function.ElementSize( geom, -1 )
  nietzsche = (10*viscosity/h) * vbasis - stressbasis.dotnorm(geom)
  stokesmat += domain.boundary.integrate( function.outer( nietzsche, vbasis ).sum(-1), geometry=geom, ischeme='gauss9' )
  rhs = domain.boundary['top'].integrate( ( nietzsche * utop ).sum(-1), geometry=geom, ischeme='gauss9' )
  lhs = stokesmat.solve( rhs, tol=tol, solver='cg', precon='spilu' )

  for iiter in log.count( 'picard', stop=maxiter ):
    if plot:
      makeplots( domain, geom, vbasis.dot(lhs), pbasis.dot(lhs), iiter )
    ugradu = ( vbasis.grad(geom) * vbasis.dot(lhs) ).sum(-1)
    convection = density * function.outer( vbasis, ugradu ).sum(-1)
    matrix = stokesmat + domain.integrate( convection, ischeme='gauss9', geometry=geom )
    lhs, info = matrix.solve( rhs, x0=lhs, tol=tol, info=True, precon='spilu', restart=999 )
    if info.niter == 0:
      break

  return lhs, info.res


def unittest():

  retvals = main( nelems=4, viscosity=1e-3, warp=False, tol=1e-15, maxiter=1, plot=False )
  assert debug.checkdata( retvals, '''
    eNpNktttQzEMQ9dJAbsw9bQGyv4r1BZv2v5EgUTRR8TFeNmAf43Xa7psf08flktvndCS97QRpnkbWFdg
    Y0qt1QqBGjt7r/tHcuFWK+wemFhRWkUpolqK8pb4znYNgKa+Aa7siDtRjwZyzzb/gE6DtFI0G/QXELjk
    Z2BsaKXxTbRjpJ3FGCXx0AVPtNxJCOSHW0HP9OcAR4/+gB0MLGRT8iFFMKhTW4E0a64V3Y9Vwbkn+9Lc
    M1PlAs4TXz+moZsOMG7Q6WSQJC7dQQqsTuUcW49UnzyXtak+8cyqe0IcSdEVRp5isCq6GLB3wOt7nE8F
    qe0DvRUYct7B2fr328qvHwXKg10=''' )

  retvals = main( nelems=4, viscosity=1e-3, warp=True, tol=1e-15, maxiter=1, plot=False )
  assert debug.checkdata( retvals, '''
    eNpVUuuNgzEIW6eVkhPmzUDdf4VL4Kt09wsHjDEoWC9dsPd6vTZg8dm2NigGlIR8ti+odoK50AUxkQGZ
    Q2W2LmmR32hVHbeK8VAjpxlJ2dRHxNVHDO45IFwbRIHbQEr3CtCqX6tyEj0N6X8NAtlKUtU8e3jIMaNU
    eXWFlG7ckNvoi0X8SehjW5yeRcIfm6H//RrKGng8l/sadboLxDKljuBrPJanVr+z2oAG7L7Fhn82ZzRw
    IrkgCZ2Yla+SaBNg1TfaTJhlLKbXyjqqmo/WGdNA2LsZbdxXsvXYONQbGTMUdoecO5n1eehnna+Cosm6
    nf2B44XPZNjU37/5EIEz''' )


util.run( main, unittest )
