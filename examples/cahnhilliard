#! /usr/bin/env python

from nutils import *


@log.title
def makeplots( domain, geom, c, mu, energies, nsteps ):

  force = mu * c.grad(geom)
  xpnt, cpnt = domain.elem_eval( [ geom, c ], ischeme='bezier4', title='mesh', separate=True )
  xy, uv = domain.elem_eval( [ geom, force ], ischeme='uniform1', title='quiver', separate=False )
  Emix, Eiface, Ewall = numpy.array(energies).T

  with plot.PyPlot( 'concentration', ndigits=4, index=len(energies) ) as plt:
    plt.mesh( xpnt, cpnt )
    plt.colorbar()
    plt.clim( -1, 1 )
    plt.quiver( xy[:,0], xy[:,1], uv[:,0], uv[:,1], pivot='middle' )
    ax = plt.gca()
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_aspect( 'equal' )
    ax = plt.axes( [.07,.05,.35,.25], axisbg='w' )
    ax.patch.set_alpha( .8 )
    for E, c, name in (Emix+Eiface+Ewall,'b','total'), (Emix,'r','mixture'), (Eiface,'g','interface'), (Ewall,'y','wall'):
      plt.plot( E, '-'+c )
      plt.plot( len(E)-1, E[-1], c+'o', label=name )
    plt.legend( numpoints=1, frameon=False, fontsize=8 )
    plt.xlim( 0, nsteps )
    plt.ylim( 0, Emix[0] + Eiface[0] )
    ax.set_xticks([])
    ax.set_yticks([])
    plt.xlabel( 'time' )
    plt.ylabel( 'energy' )


def main( nelems=20, epsilon=None, timestep=.01, maxtime=1., ewall=0, init='random', plot=True ):

  mineps = 1./nelems
  nsteps = numeric.round( maxtime / timestep )

  if epsilon is None:
    log.info( 'setting epsilon=%f' % mineps )
    epsilon = mineps
  elif epsilon < mineps:
    log.warning( 'epsilon under crititical threshold: %f < %f' % ( epsilon, mineps ) )

  xnodes = ynodes = numpy.linspace(0,1,nelems+1)
  domain, geom = mesh.rectilinear( [ xnodes, ynodes ] )

  cbasis, mubasis = function.chain([ domain.basis( 'spline', degree=2 ), domain.basis( 'spline', degree=2 ) ])

  f_p = lambda c_: 4*c_
  f_n = lambda c_: 6*c_ - 2*c_**3

  A = function.outer( cbasis ) \
    + timestep * function.outer( cbasis.grad(geom), mubasis.grad(geom) ).sum() \
    + function.outer( mubasis, mubasis - f_p(cbasis) ) \
    - epsilon**2 * function.outer( mubasis.grad(geom), cbasis.grad(geom) ).sum()

  matrix = domain.integrate( A, geometry=geom, ischeme='gauss4' )
  rhs0 = domain.boundary.integrate( mubasis * ewall, geometry=geom, ischeme='gauss4' )

  if init == 'random':
    numpy.random.seed( 0 )
    c = cbasis.dot( numpy.random.normal(0,.5,cbasis.shape) )
  elif init == 'bubbles':
    R1 = .25
    R2 = numpy.sqrt(.5) * R1 # area2 = .5 * area1
    c = 1 + function.tanh( (R1-function.norm2(geom-(.5+R2/numpy.sqrt(2)+.8*epsilon)))/epsilon ) \
          + function.tanh( (R2-function.norm2(geom-(.5-R1/numpy.sqrt(2)-.8*epsilon)))/epsilon )
  else:
    raise Exception( 'unknown init %r' % init )

  energies = []

  for istep in log.range( 'timestep', nsteps ):

    b = cbasis * c - mubasis * f_n(c)
    Emix = .5 * (c-1)**2 * (c+1)**2
    Eiface = .5 * epsilon**2 * (c.grad(geom)**2).sum(-1)
    Ewall = abs(ewall) + ewall * c

    rhs, total, energy_mix, energy_iface = domain.integrate( [ b, c, Emix, Eiface ], geometry=geom, ischeme='gauss4' )
    energy_wall = domain.boundary.integrate( Ewall, geometry=geom, ischeme='gauss4' )
    log.user( 'concentration {}, energy {}'.format( total, energy_mix + energy_iface + energy_wall ) )
    energies.append(( energy_mix, energy_iface, energy_wall ))

    lhs = matrix.solve( rhs0 + rhs, tol=1e-12, restart=999 )
    c = cbasis.dot( lhs )
    mu = mubasis.dot( lhs )

    if plot:
      makeplots( domain, geom, c, mu, energies, nsteps )

  return lhs, energies


def unittest():

  retvals = main( nelems=8, init='bubbles', maxtime=.1, plot=False )
  assert debug.checkdata( retvals, '''
    eNqFlWuOIzEIhK8zK3UkgzGPA839r7BtF5DHRlrNDxxP5+uqAjt0/chF68/18+PL7Pchly9fuxpT7LqE
    /PexrocNmXvj4THPE4+YhJ0QHrlQflsUzVcQqHLeoiSU1ElFlaJqUdd3amkr2jL284D6UGA5OLEEfvCy
    5GskbVot9NVqi2ucGMOpuUOc1ytv3el9aC5IuBYw0NG129b3BNa3bAWCULXIxcS7jJxq4e+96PjacCts
    4CQAKRAfGyotc9TJH43tXlR6bbfUFcxMzltc1vnsjDicWT6HpPranajoymkpK1iMdUx5JDwyx39G46Wr
    HWimVjZbWcEMJl17ML5A9aOl2YHKrGyWsoK5MkY29gHQy13GqbZHd110n5DjeKqh+nmemQ+Hc3QouZT5
    Fyd0H9vNnQEe3svTJHnyHx70pp7maOqS1KOGKjHAgw6KDNfZsioqvt96ihPpMwb0rFDwKL+f3GWadb3n
    k75KT3E8Pyt0MEnONvpCI2d8FC/1VD7lq/QURwT+zHMS+VwJrHuIdh3nruh8u87x6qv1FOcOJK+WdQbj
    nqi6Enmcf1Wrni2rqCsiWCtJTxQNxbiSI517QeNb27ttFXfGVPaeqhrFCgcPvq+115F8Yb61riPPqNpg
    q2rUvcAlsX+RKLRGiXOPCYebJj23Ao2l0VsMWvg+ewtP2UBWU3sLhnxBzd4aYPi5Mc7Wfcxx3oYUi0xw
    j4z924YtxZXmvKdpb91/fwHLrpoa''' )


util.run( main, unittest )
