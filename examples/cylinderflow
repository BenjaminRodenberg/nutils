#! /usr/bin/env python

from __future__ import division
from nutils import *


class MakePlots( object ):

  def __init__( self, domain, geom, xlim=(-4,12), ylim=(-6,6), video=False ):
    self.xlim = xlim
    self.ylim = ylim
    self.geom = geom
    self.plotdomain = domain.select( function.piecewise( geom[0], xlim, 0, 1, 0 ) * function.piecewise( geom[1], ylim, 0, 1, 0 ) )
    self.plt = video and plot.PyPlotVideo( 'flow' )
    self.index = 0

  def __call__( self, velo, pres ):
    self.index += 1
    vort = velo.grad(self.geom)[1,0] - velo.grad(self.geom)[0,1]
    xy, uv = self.plotdomain.elem_eval( [ self.geom, velo ], ischeme='uniform2', separate=False )
    points, flow, pres, vort = self.plotdomain.elem_eval( [ self.geom, function.norm2(velo), pres, vort ], ischeme='bezier5', separate=True )
    with self.plt if self.plt else plot.PyPlot( 'flow', index=self.index ) as plt:
      ax = plt.gcf().add_axes( [0,0,1,1], yticks=[], xticks=[], frame_on=False )
      plt.mesh( points, vort, triangulate='bezier', aspect=False )
      CS = plt.meshcontour( points, pres, triangulate='bezier', colors='k', linestyles='solid' )
      plt.clabel( CS, inline=1, fontsize=10 )
      plt.vectors( xy, uv )
      plt.xlim( self.xlim )
      plt.ylim( self.ylim )


def main( nelems=24, viscosity=1e-3, density=1, tol=1e-8, rotation=0, timestep=.1, maxradius=50, video=False ):

  Uinf = numpy.array([ 1, 0 ])

  rscale = 2*numpy.pi / nelems
  melems = numpy.ceil( numpy.log(maxradius) / rscale ).astype( int )

  log.info( 'creating {}x{} mesh, outer radius {:.2f}'.format( melems, nelems, numpy.exp( rscale * melems ) ) )

  domain, (rho,phi) = mesh.rectilinear( [range(melems+1),numpy.linspace(0,2*numpy.pi,nelems+1)], periodic=(1,) )
  normal, tangent = function.rotmat(phi)
  radius = function.exp( rscale * rho )
  geom = radius * normal
  cylvelo = rotation * tangent

  makeplots = MakePlots( domain, geom, video=video )

  vbasis = function.vectorize([ domain.basis( 'spline', degree=(3,2), removedofs=((0,),None) ), domain.basis( 'spline', degree=(2,3) ) ])
  pbasis = domain.basis( 'spline', degree=2 )

  # piola
  J = function.localgradient( geom, domain.ndims )
  detJ = function.determinant( J )
  vbasis = ( vbasis[...,_,:] * J ).sum(-1) / detJ
  pbasis = pbasis / detJ

  vbasis, pbasis, lbasis = function.chain([ vbasis, pbasis, [1.] ])
  stressbasis = (2*viscosity) * vbasis.symgrad(geom) - pbasis[:,_,_] * function.eye( domain.ndims )

  # stokes
  A = function.outer( vbasis.grad(geom), stressbasis ).sum([2,3]) \
    + function.outer( pbasis, vbasis.div(geom)+lbasis ) \
    + function.outer( lbasis, pbasis )
  Ao = function.outer( vbasis, density * ( vbasis.grad(geom) * Uinf ).sum(-1) ).sum(-1)
  At = (density/timestep) * function.outer( vbasis ).sum(-1)
  Ad = function.outer( vbasis.div(geom) )
  stokesmat, uniconvec, inertmat, divmat = domain.integrate( [ A, Ao, At, Ad ], geometry=geom, ischeme='gauss9' )

  # tangential flow boundary condition
  h = (2*numpy.pi) / nelems
  nietzsche = (2*viscosity) * ( (7.5/h) * vbasis - vbasis.symgrad(geom).dotnorm(geom) )
  B = function.outer( nietzsche, vbasis ).sum(-1)
  b = ( nietzsche * cylvelo ).sum(-1)
  bcondmat, rhs = domain.boundary['left'].integrate( [ B, b ], geometry=geom, ischeme='gauss9' )
  stokesmat += bcondmat

  cons = domain.boundary['right'].project( Uinf, geometry=geom, onto=vbasis, ischeme='gauss9', tol=1e-12 )
  lhs = (stokesmat+uniconvec).solve( rhs, constrain=cons, tol=tol, restart=9999, precon='spilu' )

  stokesmat += inertmat
  precon = (stokesmat+uniconvec).getprecon( 'splu', constrain=cons )
  for iiter in log.count( 'timestep' ):
    log.info( 'velocity divergence:', divmat.matvec(lhs).dot(lhs) )
    convection = density * ( vbasis.grad(geom) * vbasis.dot(lhs) ).sum(-1)
    matrix = stokesmat + domain.integrate( function.outer( vbasis, convection ).sum(-1), ischeme='gauss9', geometry=geom )
    lhs = matrix.solve( rhs + inertmat.matvec(lhs), lhs0=lhs, constrain=cons, tol=tol, restart=9999, precon=precon )
    makeplots( vbasis.dot(lhs), pbasis.dot(lhs) )
  

def unittest():

  pass


util.run( main, unittest )
